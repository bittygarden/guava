<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="description" content="ä¿„ç½—æ–¯æ–¹å—-åœ¨çº¿">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ‰</text></svg>">
    <title>ä¿„ç½—æ–¯æ–¹å—-åœ¨çº¿</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: #f0f0f0;
        }

        .screen {
            flex: 0.75;
            background-color: #333;
            display: flex;
            color: black;
            font-size: 24px;
            border-radius: 0px;
            padding: 10px;
            border: none;
            background-image: linear-gradient(to right, rgb(255, 236, 210) 0%, rgb(252, 182, 159) 100%);
            margin: 10px;
            box-sizing: border-box;
            min-height: 0;
            /* é˜²æ­¢flexå¸ƒå±€æº¢å‡º */
        }

        .game {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
            box-sizing: border-box;
            min-width: 0;
            /* é˜²æ­¢flexå¸ƒå±€æº¢å‡º */
            padding: 0;
            /* ç§»é™¤å†…è¾¹è· */
        }

        .game #gameCanvas {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            border: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -webkit-image-rendering: pixelated;
            -moz-image-rendering: pixelated;
            -ms-image-rendering: pixelated;
            -webkit-image-rendering: crisp-edges;
            -moz-image-rendering: crisp-edges;
            -ms-image-rendering: crisp-edges;
        }

        .game-info {
            flex: 0.3;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            background-color: white;
            border-left: 4px solid #fdc4ac;
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
            font-size: 20px;
            min-width: 120px;
        }

        .next-piece {
            width: 100%;
            aspect-ratio: 1;
            background-color: #f3f1ee;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
        }

        .next-piece canvas {
            width: 80%;
            height: 80%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            -webkit-image-rendering: pixelated;
            -moz-image-rendering: pixelated;
            -ms-image-rendering: pixelated;
            -webkit-image-rendering: crisp-edges;
            -moz-image-rendering: crisp-edges;
            -ms-image-rendering: crisp-edges;
        }

        .buttons {
            flex: 0.25;
            background-color: #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            border-radius: 0px;
            background-image: linear-gradient(to right, rgb(255, 236, 210) 0%, rgb(252, 182, 159) 100%);
            margin: 10px;
            box-sizing: border-box;
            min-height: 0;
            /* é˜²æ­¢flexå¸ƒå±€æº¢å‡º */
        }

        .control-buttons {
            display: flex;
            flex-direction: column;
            min-width: 100px;
            /* è®¾ç½®æœ€å°å®½åº¦ */
        }

        .control-buttons button {
            margin: 5px;
            padding: 8px 16px;
            font-size: 16px;
            border: none;
            border: 1px solid white;
            color: white;
            background-color: #16d9e3;
            border-radius: 8px;
            min-width: 80px;
            /* è®¾ç½®æœ€å°å®½åº¦ */
        }

        .control-buttons button.pause {
            background-color: #ff8e0d;
        }

        .direction-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            min-width: 150px;
            /* è®¾ç½®æœ€å°å®½åº¦ */
        }

        .direction-buttons button:nth-child(1) {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
        }

        .direction-buttons button:nth-child(2) {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
        }

        .direction-buttons button:nth-child(3) {
            display: none;
            grid-column: 2 / 3;
            grid-row: 2 / 3;
        }

        .direction-buttons button:nth-child(4) {
            grid-column: 3 / 4;
            grid-row: 2 / 3;
        }

        .direction-buttons button:nth-child(5) {
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }

        .direction-buttons button {
            padding: 8px;
            font-size: 16px;
            border: none;
            border: 1px solid white;
            color: white;
            background-color: #16d9e3;
            border-radius: 8px;
            min-width: 40px;
            /* è®¾ç½®æœ€å°å®½åº¦ */
        }

        @media (min-width: 768px) {
            .screen {
                flex: 0.8;
            }

            .buttons {
                flex: 0.2;
            }

            .game-info {
                font-size: 24px;
            }

            .control-buttons button,
            .direction-buttons button {
                font-size: 18px;
                padding: 10px 20px;
            }
        }

        @media (max-width: 768px) {
            .screen {
                flex: 0.65;
                padding: 5px;
                margin: 5px;
            }

            .buttons {
                flex: 0.35;
                padding: 5px 10px;
                margin: 5px;
            }

            .game-info {
                font-size: 16px;
                min-width: 80px;
                padding: 5px;
            }

            .control-buttons button,
            .direction-buttons button {
                font-size: 14px;
                padding: 6px 12px;
                min-width: 70px;
            }
        }

        .control-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <div class="screen">
        <div class="game">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div class="game-info">
            <div id="score">å¾—åˆ†: 0</div>
            <div id="level">ç­‰çº§: 1</div>
            <div>ä¸‹ä¸€ä¸ª:</div>
            <div class="next-piece">
                <canvas id="nextPieceCanvas"></canvas>
            </div>
            <div id="gameStatus" style="display: none; color: red; font-weight: bold; margin-top: 10px;"></div>
        </div>
    </div>
    <div class="buttons">
        <div class="control-buttons">
            <button id="startButton">å¼€å§‹</button>
            <button id="pauseButton" class="pause">æš‚åœ</button>
            <button id="fullscreenToggle">å…¨å±</button>
        </div>
        <div class="direction-buttons">
            <button id="upButton">ä¸Š</button>
            <button id="leftButton">å·¦</button>
            <button></button>
            <button id="rightButton">å³</button>
            <button id="downButton">ä¸‹</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const gameStatusElement = document.getElementById('gameStatus');
        const startButton = document.getElementById('startButton');
        const pauseButton = document.getElementById('pauseButton');
        const fullscreenToggle = document.getElementById('fullscreenToggle');
        const upButton = document.getElementById('upButton');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const downButton = document.getElementById('downButton');
        const nextPieceCanvas = document.getElementById('nextPieceCanvas');
        const nextPieceCtx = nextPieceCanvas.getContext('2d');

        const gameDiv = canvas.parentNode;

        let ROWS;
        let COLS;
        let BLOCK_SIZE;

        function setCanvasSize() {
            const gameDivWidth = gameDiv.offsetWidth;
            const gameDivHeight = gameDiv.offsetHeight;

            // è®¡ç®—åˆé€‚çš„æ–¹å—å¤§å°ï¼Œç¡®ä¿æ˜¯æ•´æ•°
            const blockSize = Math.floor(Math.min(gameDivWidth * 0.95, gameDivHeight * 0.7) / 10);

            // è®¾ç½®ç”»å¸ƒå¤§å°ï¼Œç¡®ä¿æ˜¯æ–¹å—å¤§å°çš„æ•´æ•°å€
            canvas.width = blockSize * 10;
            canvas.height = blockSize * 20;

            // è®¾ç½®é¢„è§ˆç”»å¸ƒå¤§å°
            const previewSize = Math.min(nextPieceCanvas.parentElement.offsetWidth, nextPieceCanvas.parentElement.offsetHeight) * 0.8;
            nextPieceCanvas.width = previewSize;
            nextPieceCanvas.height = previewSize;

            calculateRowsAndCols();
            calculateBlockSize();

            // å¦‚æœæ¸¸æˆæ²¡æœ‰ç»“æŸï¼Œæ‰åˆå§‹åŒ–æ¸¸æˆæ¿
            if (!isGameOver) {
                initializeBoard();
            }

            // åˆå§‹åŒ–ç¬¬ä¸€ä¸ªæ–¹å—
            if (!currentPiece && !isGameOver) {
                const randomIndex = Math.floor(Math.random() * SHAPES.length);
                currentPiece = SHAPES[randomIndex];
                currentColor = COLORS[randomIndex];
                currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
                currentY = 0;
                // ç”Ÿæˆä¸‹ä¸€ä¸ªæ–¹å—
                const nextRandomIndex = Math.floor(Math.random() * SHAPES.length);
                nextPiece = SHAPES[nextRandomIndex];
                nextColor = COLORS[nextRandomIndex];
            }
            draw();
            drawNextPiece();
        }

        function calculateRowsAndCols() {
            COLS = 10;  // å›ºå®šåˆ—æ•°ä¸º10
            ROWS = 20;  // å›ºå®šè¡Œæ•°ä¸º20
        }

        function calculateBlockSize() {
            BLOCK_SIZE = canvas.width / COLS;
        }

        function initializeBoard() {
            board = [];
            for (let i = 0; i < ROWS; i++) {
                board[i] = [];
                for (let j = 0; j < COLS; j++) {
                    board[i][j] = 0;
                }
            }
        }

        window.addEventListener('load', setCanvasSize);
        window.addEventListener('resize', setCanvasSize);
        document.addEventListener('fullscreenchange', setCanvasSize);

        let board = [];

        const SHAPES = [
            [[1, 1, 1, 1]],
            [[1, 1], [1, 1]],
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1, 1], [1, 1, 0]],
            [[1, 1, 1], [0, 1, 0]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1, 1], [0, 0, 1]]
        ];

        const COLORS = [
            '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'
        ];

        let currentPiece;
        let nextPiece;
        let currentX;
        let currentY;
        let currentColor;
        let nextColor;
        let score = 0;
        let level = 1;
        let intervalId;
        let isPaused = false;
        let isGameOver = false;
        let gameState = {
            board: [],
            currentPiece: null,
            currentX: 0,
            currentY: 0,
            currentColor: '',
            score: 0,
            level: 1
        };

        function saveGameState() {
            gameState = {
                board: JSON.parse(JSON.stringify(board)),
                currentPiece: currentPiece ? JSON.parse(JSON.stringify(currentPiece)) : null,
                currentX,
                currentY,
                currentColor,
                score,
                level
            };
            localStorage.setItem('tetrisGameState', JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('tetrisGameState');
            if (savedState) {
                gameState = JSON.parse(savedState);
                board = JSON.parse(JSON.stringify(gameState.board));
                currentPiece = gameState.currentPiece ? JSON.parse(JSON.stringify(gameState.currentPiece)) : null;
                currentX = gameState.currentX;
                currentY = gameState.currentY;
                currentColor = gameState.currentColor;
                score = gameState.score;
                level = gameState.level;
                scoreElement.textContent = `å¾—åˆ†: ${score}`;
                levelElement.textContent = `ç­‰çº§: ${level}`;
                draw();
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(intervalId);
                pauseButton.textContent = 'ç»§ç»­';
                saveGameState();
            } else {
                pauseButton.textContent = 'æš‚åœ';
                intervalId = setInterval(moveDown, 500 / level);
            }
        }

        function newPiece() {
            if (!nextPiece) {
                const randomIndex = Math.floor(Math.random() * SHAPES.length);
                nextPiece = SHAPES[randomIndex];
                nextColor = COLORS[randomIndex];
            }

            currentPiece = nextPiece;
            currentColor = nextColor;
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
            currentY = 0;

            // ç”Ÿæˆä¸‹ä¸€ä¸ªæ–¹å—
            const randomIndex = Math.floor(Math.random() * SHAPES.length);
            nextPiece = SHAPES[randomIndex];
            nextColor = COLORS[randomIndex];

            if (collision()) {
                gameOver();
            }

            drawNextPiece();
        }

        function drawNextPiece() {
            if (!nextPiece) return;

            nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);

            const blockSize = nextPieceCanvas.width / 4;
            const offsetX = (nextPieceCanvas.width - nextPiece[0].length * blockSize) / 2;
            const offsetY = (nextPieceCanvas.height - nextPiece.length * blockSize) / 2;

            for (let i = 0; i < nextPiece.length; i++) {
                for (let j = 0; j < nextPiece[i].length; j++) {
                    if (nextPiece[i][j]) {
                        const x = offsetX + j * blockSize;
                        const y = offsetY + i * blockSize;
                        const size = blockSize;
                        nextPieceCtx.fillStyle = nextColor;
                        nextPieceCtx.fillRect(x, y, size, size);
                        nextPieceCtx.strokeStyle = '#000000';
                        nextPieceCtx.lineWidth = 1;
                        nextPieceCtx.beginPath();
                        nextPieceCtx.rect(x, y, size, size);
                        nextPieceCtx.stroke();
                    }
                }
            }
        }

        function drawBoard() {
            for (let i = 0; i < ROWS; i++) {
                for (let j = 0; j < COLS; j++) {
                    if (board[i][j]) {
                        const x = j * BLOCK_SIZE;
                        const y = i * BLOCK_SIZE;
                        const size = BLOCK_SIZE;
                        ctx.fillStyle = COLORS[board[i][j] - 1];
                        ctx.fillRect(x, y, size, size);
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.rect(x, y, size, size);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawPiece() {
            if (currentPiece) {
                for (let i = 0; i < currentPiece.length; i++) {
                    for (let j = 0; j < currentPiece[i].length; j++) {
                        if (currentPiece[i][j]) {
                            const x = (currentX + j) * BLOCK_SIZE;
                            const y = (currentY + i) * BLOCK_SIZE;
                            const size = BLOCK_SIZE;
                            ctx.fillStyle = currentColor;
                            ctx.fillRect(x, y, size, size);
                            ctx.strokeStyle = '#000000';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.rect(x, y, size, size);
                            ctx.stroke();
                        }
                    }
                }
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function draw() {
            clearCanvas();
            drawBoard();
            drawPiece();
        }

        function collision() {
            for (let i = 0; i < currentPiece.length; i++) {
                for (let j = 0; j < currentPiece[i].length; j++) {
                    if (currentPiece[i][j]) {
                        const newX = currentX + j;
                        const newY = currentY + i;

                        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºåº•éƒ¨è¾¹ç•Œ
                        if (newY >= ROWS) {
                            return true;
                        }

                        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºå·¦å³è¾¹ç•Œ
                        if (newX < 0 || newX >= COLS) {
                            return true;
                        }

                        // æ£€æŸ¥æ˜¯å¦ä¸å·²æœ‰æ–¹å—ç¢°æ’
                        if (newY >= 0 && board[newY] && board[newY][newX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function mergePiece() {
            for (let i = 0; i < currentPiece.length; i++) {
                for (let j = 0; j < currentPiece[i].length; j++) {
                    if (currentPiece[i][j]) {
                        const row = currentY + i;
                        const col = currentX + j;
                        if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                            board[row][col] = COLORS.indexOf(currentColor) + 1;
                        }
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;
            for (let i = 0; i < ROWS; i++) {
                if (board[i].every(cell => cell)) {
                    linesCleared++;
                    board.splice(i, 1);
                    board.unshift(new Array(COLS).fill(0));
                }
            }
            if (linesCleared) {
                // æ ¹æ®æ¶ˆé™¤çš„è¡Œæ•°è®¡ç®—å¾—åˆ†
                let points = 0;
                switch (linesCleared) {
                    case 1:
                        points = 100;
                        break;
                    case 2:
                        points = 150;
                        break;
                    case 3:
                        points = 200;
                        break;
                    case 4:
                        points = 300;
                        break;
                }
                // å¾—åˆ†ä¹˜ä»¥å½“å‰ç­‰çº§
                score += points * level;
                scoreElement.textContent = `å¾—åˆ†: ${score}`;
                if (score >= level * 1000) {
                    level++;
                    levelElement.textContent = `ç­‰çº§: ${level}`;
                    clearInterval(intervalId);
                    // ä¿®æ”¹é€Ÿåº¦è®¡ç®—å…¬å¼ï¼Œä½¿é€Ÿåº¦å¢åŠ æ›´æ…¢
                    const baseSpeed = 500; // åŸºç¡€é€Ÿåº¦ï¼ˆæ¯«ç§’ï¼‰
                    const speedDecrease = 30; // æ¯çº§å‡å°‘çš„æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                    const newSpeed = Math.max(100, baseSpeed - (level - 1) * speedDecrease); // æœ€å°é€Ÿåº¦ä¸º100æ¯«ç§’
                    intervalId = setInterval(moveDown, newSpeed);
                }
            }
        }

        function moveDown() {
            if (isPaused) return;

            currentY++;
            if (collision()) {
                currentY--;
                mergePiece();
                clearLines();
                // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾é¡¶éƒ¨
                if (currentY <= 0) {
                    gameOver();
                } else {
                    newPiece();
                }
            }
            draw();
        }

        function moveLeft() {
            if (isPaused) return;
            currentX--;
            if (collision()) {
                currentX++;
            }
            draw();
        }

        function moveRight() {
            if (isPaused) return;
            currentX++;
            if (collision()) {
                currentX--;
            }
            draw();
        }

        function rotate() {
            const rotatedPiece = [];
            for (let i = 0; i < currentPiece[0].length; i++) {
                rotatedPiece[i] = [];
                for (let j = currentPiece.length - 1; j >= 0; j--) {
                    rotatedPiece[i][currentPiece.length - 1 - j] = currentPiece[j][i];
                }
            }
            const tempPiece = currentPiece;
            currentPiece = rotatedPiece;
            if (collision()) {
                let newX = currentX;
                if (newX > 0) {
                    currentX--;
                    if (!collision()) {
                        draw();
                        return;
                    }
                    currentX++;
                }
                if (newX < COLS - rotatedPiece[0].length) {
                    currentX++;
                    if (!collision()) {
                        draw();
                        return;
                    }
                    currentX--;
                }
                currentPiece = tempPiece;
            }
            draw();
        }

        function gameOver() {
            clearInterval(intervalId);
            // åœ¨æ¸¸æˆç»“æŸå‰ï¼Œå°†æœ€åä¸€ä¸ªæ–¹å—å›ºå®šåˆ°æ¸¸æˆæ¿ä¸Š
            if (currentPiece) {
                mergePiece();
                draw();
            }
            gameStatusElement.textContent = `æ¸¸æˆç»“æŸï¼å¾—åˆ†: ${score}`;
            gameStatusElement.style.display = 'block';
            localStorage.removeItem('tetrisGameState');
            isPaused = false;
            isGameOver = true;
            pauseButton.textContent = 'æš‚åœ';
            startButton.textContent = 'é‡æ–°å¼€å§‹';
            startButton.disabled = false;
            pauseButton.disabled = true;
            fullscreenToggle.disabled = false;
            upButton.disabled = true;
            leftButton.disabled = true;
            rightButton.disabled = true;
            downButton.disabled = true;
            nextPiece = null;
            drawNextPiece();
        }

        function startGame() {
            if (intervalId) {
                clearInterval(intervalId);
            }
            isPaused = false;
            isGameOver = false;
            pauseButton.textContent = 'æš‚åœ';
            startButton.textContent = 'å¼€å§‹';
            startButton.disabled = true;
            pauseButton.disabled = false;
            fullscreenToggle.disabled = true;
            upButton.disabled = false;
            leftButton.disabled = false;
            rightButton.disabled = false;
            downButton.disabled = false;
            gameStatusElement.style.display = 'none';
            initializeBoard();
            score = 0;
            level = 1;
            scoreElement.textContent = `å¾—åˆ†: ${score}`;
            levelElement.textContent = `ç­‰çº§: ${level}`;
            // å¦‚æœå½“å‰æ²¡æœ‰æ–¹å—ï¼Œæ‰ç”Ÿæˆæ–°çš„æ–¹å—
            if (!currentPiece) {
                newPiece();
            }
            // ä½¿ç”¨ç›¸åŒçš„é€Ÿåº¦è®¡ç®—å…¬å¼
            const baseSpeed = 500;
            const speedDecrease = 30;
            const newSpeed = Math.max(100, baseSpeed - (level - 1) * speedDecrease);
            intervalId = setInterval(moveDown, newSpeed);
        }

        startButton.addEventListener('click', startGame);

        pauseButton.addEventListener('click', togglePause);

        fullscreenToggle.addEventListener('click', function () {
            const elem = document.documentElement;
            if (document.fullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                fullscreenToggle.textContent = 'å…¨å±';
            } else {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
                fullscreenToggle.textContent = 'é€€å‡ºå…¨å±';
            }
            // å…¨å±åˆ‡æ¢åé‡æ–°è®¾ç½®ç”»å¸ƒå¤§å°ï¼Œä½†ä¸æ¸…ç©ºæ¸¸æˆçŠ¶æ€
            setCanvasSize();
        });

        // ä¿®æ”¹å…¨å±å˜åŒ–äº‹ä»¶ç›‘å¬
        document.addEventListener('fullscreenchange', function () {
            setCanvasSize();
        });

        upButton.addEventListener('click', rotate);
        leftButton.addEventListener('click', moveLeft);
        rightButton.addEventListener('click', moveRight);
        downButton.addEventListener('click', moveDown);

        document.addEventListener('keydown', function (event) {
            if (isPaused || isGameOver || startButton.disabled === false) return;

            switch (event.key) {
                case 'ArrowUp':
                    rotate();
                    break;
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowDown':
                    moveDown();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
        });

        // é¡µé¢åŠ è½½æ—¶è®¾ç½®åˆå§‹æŒ‰é’®çŠ¶æ€
        window.addEventListener('load', function () {
            setCanvasSize();
            loadGameState();
            pauseButton.disabled = true;
            fullscreenToggle.disabled = false;
            upButton.disabled = true;
            leftButton.disabled = true;
            rightButton.disabled = true;
            downButton.disabled = true;
            // å¦‚æœæ¸¸æˆçŠ¶æ€ä¸ºç©ºï¼Œåˆå§‹åŒ–ç¬¬ä¸€ä¸ªæ–¹å—
            if (!currentPiece) {
                const randomIndex = Math.floor(Math.random() * SHAPES.length);
                currentPiece = SHAPES[randomIndex];
                currentColor = COLORS[randomIndex];
                currentX = Math.floor(COLS / 2) - Math.floor(currentPiece[0].length / 2);
                currentY = 0;
                // ç”Ÿæˆä¸‹ä¸€ä¸ªæ–¹å—
                const nextRandomIndex = Math.floor(Math.random() * SHAPES.length);
                nextPiece = SHAPES[nextRandomIndex];
                nextColor = COLORS[nextRandomIndex];
                draw();
                drawNextPiece();
            }
        });
    </script>
</body>

</html>