<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RFTZ7J5H90"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-RFTZ7J5H90');
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ä¸€ä¸ªåœ¨çº¿å·¥å…·ï¼Œç”¨äºåœ¨ä¸åŒç¼–ç æ ¼å¼ï¼ˆBase16ã€Base32ã€Base58ã€Base64ã€Base64urlï¼‰ä¹‹é—´è½¬æ¢æ–‡æœ¬ã€‚åªéœ€è¾“å…¥æ–‡æœ¬å³å¯æŸ¥çœ‹è½¬æ¢ç»“æœã€‚">
    <link rel="icon" href="/favicon.ico" type="image/x-icon" />
    <title>ç¼–ç è½¬æ¢å™¨ - Base16, Base32, Base58, Base64, Base64url</title>
    <link rel="stylesheet" href="../../../styles/floating-button.css">
    <link rel="stylesheet" href="../base.css">
</head>

<body>
    <div class="inputDiv" style="display: flex; align-items: stretch; margin-bottom: 30px; height: 30%;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap;">è¾“å…¥æ–‡æœ¬ï¼š</label>
        <textarea class="inputText" id="inputText" placeholder="è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬" rows="6" style="flex: 1; resize: vertical; padding: 0; border: 1px solid #ccc; box-sizing: border-box;"></textarea>
        <button id="modeToggle" style="margin-left: 5px; height: 100%; width: auto; aspect-ratio: 1/1; padding: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer; box-sizing: border-box; font-weight: bold; font-size: 18px; display: flex; position: relative; justify-content: center; align-items: center;">ç¼–ç <span style="font-size: 10px; font-weight: normal; position: absolute; bottom: 2px; right: 2px;">ç‚¹å‡»åˆ‡æ¢</span></button>
    </div>

    <div class="outputDiv" style="display: flex; align-items: stretch;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap; align-self: center;">Base16ï¼š</label>
        <textarea class="outputText" id="base16Output" readonly placeholder="Base16ç¼–ç ç»“æœ" rows="3" style="flex: 1; margin-right: 5px; resize: vertical;"></textarea>
        <button id="copyBase16" style="height: 100%; width: 60px; padding: 0; margin: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer;">å¤åˆ¶</button>
    </div>

    <div class="outputDiv" style="display: flex; align-items: stretch; margin-top: 10px;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap; align-self: center;">Base32ï¼š</label>
        <textarea class="outputText" id="base32Output" readonly placeholder="Base32ç¼–ç ç»“æœ" rows="3" style="flex: 1; margin-right: 5px; resize: vertical;"></textarea>
        <button id="copyBase32" style="height: 100%; width: 60px; padding: 0; margin: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer;">å¤åˆ¶</button>
    </div>

    <div class="outputDiv" style="display: flex; align-items: stretch; margin-top: 10px;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap; align-self: center;">Base58ï¼š</label>
        <textarea class="outputText" id="base58Output" readonly placeholder="Base58ç¼–ç ç»“æœ" rows="3" style="flex: 1; margin-right: 5px; resize: vertical;"></textarea>
        <button id="copyBase58" style="height: 100%; width: 60px; padding: 0; margin: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer;">å¤åˆ¶</button>
    </div>

    <div class="outputDiv" style="display: flex; align-items: stretch; margin-top: 10px;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap; align-self: center;">Base64ï¼š</label>
        <textarea class="outputText" id="base64Output" readonly placeholder="Base64ç¼–ç ç»“æœ" rows="3" style="flex: 1; margin-right: 5px; resize: vertical;"></textarea>
        <button id="copyBase64" style="height: 100%; width: 60px; padding: 0; margin: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer;">å¤åˆ¶</button>
    </div>

    <div class="outputDiv" style="display: flex; align-items: stretch; margin-top: 10px;">
        <label style="margin-right: 5px; width: 120px; white-space: nowrap; align-self: center;">Base64urlï¼š</label>
        <textarea class="outputText" id="base64urlOutput" readonly placeholder="Base64urlç¼–ç ç»“æœ" rows="3" style="flex: 1; margin-right: 5px; resize: vertical;"></textarea>
        <button id="copyBase64url" style="height: 100%; width: 60px; padding: 0; margin: 0; border: 1px solid #94b76c; border-radius: 4px; background-color: #94b76c; color: white; cursor: pointer;">å¤åˆ¶</button>
    </div>



    <script>
        const inputText = document.getElementById('inputText');
        const base16Output = document.getElementById('base16Output');
        const base32Output = document.getElementById('base32Output');
        const base58Output = document.getElementById('base58Output');
        const base64Output = document.getElementById('base64Output');
        const base64urlOutput = document.getElementById('base64urlOutput');

        const copyBase16 = document.getElementById('copyBase16');
        const copyBase32 = document.getElementById('copyBase32');
        const copyBase58 = document.getElementById('copyBase58');
        const copyBase64 = document.getElementById('copyBase64');
        const copyBase64url = document.getElementById('copyBase64url');
        const modeToggle = document.getElementById('modeToggle');
        
        // æ¨¡å¼çŠ¶æ€å˜é‡ï¼štrue ä¸ºç¼–ç æ¨¡å¼ï¼Œfalse ä¸ºè§£ç æ¨¡å¼
        let isEncodeMode = true;

        // Base16ç¼–ç å‡½æ•°
        function base16Encode(str) {
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºUTF-8å­—èŠ‚
            const encoder = new TextEncoder();
            const bytes = encoder.encode(str);
            
            let result = '';
            for (let i = 0; i < bytes.length; i++) {
                result += bytes[i].toString(16).padStart(2, '0').toUpperCase();
            }
            return result;
        }

        // Base32ç¼–ç å‡½æ•°
        function base32Encode(str) {
            const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let result = '';
            let bits = 0;
            let value = 0;
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºUTF-8å­—èŠ‚
            const encoder = new TextEncoder();
            const bytes = encoder.encode(str);
            
            for (let i = 0; i < bytes.length; i++) {
                value = (value << 8) | bytes[i];
                bits += 8;
                
                while (bits >= 5) {
                    result += base32Chars[(value >>> (bits - 5)) & 31];
                    bits -= 5;
                }
            }
            
            // å¤„ç†å‰©ä½™çš„ä½
            if (bits > 0) {
                result += base32Chars[(value << (5 - bits)) & 31];
            }
            
            return result;
        }

        // Base58ç¼–ç å‡½æ•°
        function base58Encode(str) {
            const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            
            // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºUTF-8å­—èŠ‚
            const encoder = new TextEncoder();
            const bytes = encoder.encode(str);
            
            // å¤„ç†å‰å¯¼é›¶å­—èŠ‚ï¼ˆè½¬æ¢ä¸º'1'å­—ç¬¦ï¼‰
            let leadingZeros = 0;
            while (leadingZeros < bytes.length && bytes[leadingZeros] === 0) {
                leadingZeros++;
            }
            
            const digits = [0]; // å­˜å‚¨58è¿›åˆ¶æ•°å­—
            for (let i = 0; i < bytes.length; i++) {
                let carry = bytes[i];
                for (let j = 0; j < digits.length; j++) {
                    carry += digits[j] * 256;
                    digits[j] = carry % 58;
                    carry = Math.floor(carry / 58);
                }
                while (carry > 0) {
                    digits.push(carry % 58);
                    carry = Math.floor(carry / 58);
                }
            }
            
            // æ„å»ºç»“æœ
            let result = '';
            for (let i = 0; i < leadingZeros; i++) {
                result += '1'; // æ·»åŠ å‰å¯¼'1'å¯¹åº”å‰å¯¼é›¶å­—èŠ‚
            }
            for (let i = digits.length - 1; i >= 0; i--) {
                result += ALPHABET[digits[i]];
            }
            
            return result;
        }

        // Base64urlç¼–ç å‡½æ•°
        function base64urlEncode(str) {
            // å…ˆè¿›è¡ŒBase64ç¼–ç 
            const base64 = btoa(unescape(encodeURIComponent(str)));
            
            // å°†Base64è½¬æ¢ä¸ºBase64urlï¼šæ›¿æ¢'+'ä¸º'-'ï¼Œ'/'ä¸º'_'ï¼Œç§»é™¤å°¾éƒ¨çš„'='å¡«å……
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }


        // Base16è§£ç å‡½æ•°
        function base16Decode(hexStr) {
            // éªŒè¯è¾“å…¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²
            if (!/^[0-9A-Fa-f]*$/.test(hexStr)) {
                throw new Error('æ— æ•ˆçš„Base16æ ¼å¼');
            }
            
            if (hexStr.length % 2 !== 0) {
                throw new Error('Base16å­—ç¬¦ä¸²é•¿åº¦å¿…é¡»ä¸ºå¶æ•°');
            }
            
            const bytes = new Uint8Array(hexStr.length / 2);
            for (let i = 0; i < hexStr.length; i += 2) {
                bytes[i / 2] = parseInt(hexStr.substr(i, 2), 16);
            }
            
            const decoder = new TextDecoder();
            return decoder.decode(bytes);
        }
        
        // Base32è§£ç å‡½æ•°
        function base32Decode(encoded) {
            const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            const charMap = {};
            for (let i = 0; i < base32Chars.length; i++) {
                charMap[base32Chars[i]] = i;
            }
            
            // éªŒè¯è¾“å…¥
            encoded = encoded.toUpperCase();
            if (!/^[A-Z2-7]*$/.test(encoded)) {
                throw new Error('æ— æ•ˆçš„Base32æ ¼å¼');
            }
            
            let bits = 0;
            let value = 0;
            const bytes = [];
            
            for (let i = 0; i < encoded.length; i++) {
                value = (value << 5) | charMap[encoded[i]];
                bits += 5;
                
                while (bits >= 8) {
                    bytes.push((value >>> (bits - 8)) & 255);
                    bits -= 8;
                }
            }
            
            const decoder = new TextDecoder();
            return decoder.decode(new Uint8Array(bytes));
        }
        
        // Base58è§£ç å‡½æ•°
        function base58Decode(encoded) {
            const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            const charMap = {};
            for (let i = 0; i < ALPHABET.length; i++) {
                charMap[ALPHABET[i]] = i;
            }
            
            // éªŒè¯è¾“å…¥
            if (!/^[1-9A-HJ-NP-Za-km-z]*$/.test(encoded)) {
                throw new Error('æ— æ•ˆçš„Base58æ ¼å¼');
            }
            
            // å¤„ç†å‰å¯¼'1'å­—ç¬¦ï¼ˆè½¬æ¢ä¸ºé›¶å­—èŠ‚ï¼‰
            let leadingZeros = 0;
            while (leadingZeros < encoded.length && encoded[leadingZeros] === '1') {
                leadingZeros++;
            }
            
            // è½¬æ¢ä¸º256è¿›åˆ¶
            const digits = [0];
            for (let i = 0; i < encoded.length; i++) {
                let carry = charMap[encoded[i]];
                for (let j = 0; j < digits.length; j++) {
                    carry += digits[j] * 58;
                    digits[j] = carry % 256;
                    carry = Math.floor(carry / 256);
                }
                while (carry > 0) {
                    digits.push(carry % 256);
                    carry = Math.floor(carry / 256);
                }
            }
            
            // æ„å»ºç»“æœå­—èŠ‚æ•°ç»„
            const bytes = new Uint8Array(leadingZeros + digits.length);
            for (let i = leadingZeros; i < bytes.length; i++) {
                bytes[i] = digits[bytes.length - 1 - i];
            }
            
            const decoder = new TextDecoder();
            return decoder.decode(bytes);
        }
        
        // Base64è§£ç å‡½æ•°
        function base64Decode(encoded) {
            try {
                return decodeURIComponent(escape(atob(encoded)));
            } catch (error) {
                throw new Error('æ— æ•ˆçš„Base64æ ¼å¼');
            }
        }
        
        // Base64urlè§£ç å‡½æ•°
        function base64urlDecode(encoded) {
            // å°†Base64urlè½¬æ¢å›Base64æ ¼å¼
            encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');
            // æ·»åŠ ç¼ºå¤±çš„å¡«å……
            const paddingNeeded = 4 - (encoded.length % 4);
            if (paddingNeeded < 4) {
                encoded += '='.repeat(paddingNeeded);
            }
            
            try {
                return decodeURIComponent(escape(atob(encoded)));
            } catch (error) {
                throw new Error('æ— æ•ˆçš„Base64urlæ ¼å¼');
            }
        }
        
        function convertEncoding() {
            const text = inputText.value;
            
            if (text === "") {
                base16Output.value = "";
                base32Output.value = "";
                base58Output.value = "";
                base64Output.value = "";
                base64urlOutput.value = "";
                copyBase16.textContent = "å¤åˆ¶";
                copyBase32.textContent = "å¤åˆ¶";
                copyBase58.textContent = "å¤åˆ¶";
                copyBase64.textContent = "å¤åˆ¶";
                copyBase64url.textContent = "å¤åˆ¶";
                return;
            }

            if (isEncodeMode) {
                // ç¼–ç æ¨¡å¼
                try {
                    // Base16ç¼–ç 
                    const base16 = base16Encode(text);
                    base16Output.value = base16;

                    // Base32ç¼–ç 
                    const base32 = base32Encode(text);
                    base32Output.value = base32;

                    // Base58ç¼–ç 
                    const base58 = base58Encode(text);
                    base58Output.value = base58;

                    // Base64ç¼–ç 
                    const base64 = btoa(unescape(encodeURIComponent(text)));
                    base64Output.value = base64;

                    // Base64urlç¼–ç 
                    const base64url = base64urlEncode(text);
                    base64urlOutput.value = base64url;
                } catch (error) {
                    console.error('ç¼–ç è½¬æ¢æ—¶å‡ºé”™:', error);
                    base16Output.value = "ç¼–ç å‡ºé”™ï¼š" + error.message;
                    base32Output.value = "ç¼–ç å‡ºé”™ï¼š" + error.message;
                    base58Output.value = "ç¼–ç å‡ºé”™ï¼š" + error.message;
                    base64Output.value = "ç¼–ç å‡ºé”™ï¼š" + error.message;
                    base64urlOutput.value = "ç¼–ç å‡ºé”™ï¼š" + error.message;
                }
            } else {
                // è§£ç æ¨¡å¼ï¼Œå¯¹æ¯ç§ç¼–ç åˆ†åˆ«å¤„ç†é”™è¯¯
                // Base16è§£ç 
                try {
                    base16Output.value = base16Decode(text);
                } catch (error) {
                    base16Output.value = "è§£ç å‡ºé”™ï¼š" + error.message;
                }
                
                // Base32è§£ç 
                try {
                    base32Output.value = base32Decode(text);
                } catch (error) {
                    base32Output.value = "è§£ç å‡ºé”™ï¼š" + error.message;
                }
                
                // Base58è§£ç 
                try {
                    base58Output.value = base58Decode(text);
                } catch (error) {
                    base58Output.value = "è§£ç å‡ºé”™ï¼š" + error.message;
                }
                
                // Base64è§£ç 
                try {
                    base64Output.value = base64Decode(text);
                } catch (error) {
                    base64Output.value = "è§£ç å‡ºé”™ï¼š" + error.message;
                }
                
                // Base64urlè§£ç 
                try {
                    base64urlOutput.value = base64urlDecode(text);
                } catch (error) {
                    base64urlOutput.value = "è§£ç å‡ºé”™ï¼š" + error.message;
                }
            }
            
            // é‡ç½®å¤åˆ¶æŒ‰é’®æ–‡æœ¬
            copyBase16.textContent = "å¤åˆ¶";
            copyBase32.textContent = "å¤åˆ¶";
            copyBase58.textContent = "å¤åˆ¶";
            copyBase64.textContent = "å¤åˆ¶";
            copyBase64url.textContent = "å¤åˆ¶";
        }
        
        // åˆ‡æ¢ç¼–ç /è§£ç æ¨¡å¼
        function toggleMode() {
            isEncodeMode = !isEncodeMode;
            // æ›´æ–°æŒ‰é’®HTMLå†…å®¹ä¸ºå½“å‰æ¨¡å¼å’Œå³ä¸‹è§’æç¤ºæ–‡å­—
            modeToggle.innerHTML = isEncodeMode ? "ç¼–ç <span style='font-size: 10px; font-weight: normal; position: absolute; bottom: 2px; right: 2px;'>ç‚¹å‡»åˆ‡æ¢</span>" : "è§£ç <span style='font-size: 10px; font-weight: normal; position: absolute; bottom: 2px; right: 2px;'>ç‚¹å‡»åˆ‡æ¢</span>";
            
            // æ ¹æ®æ¨¡å¼åˆ‡æ¢æŒ‰é’®é¢œè‰²
            if (isEncodeMode) {
                modeToggle.style.backgroundColor = '#94b76c';
                modeToggle.style.borderColor = '#94b76c';
            } else {
                modeToggle.style.backgroundColor = '#57aa7f';
                modeToggle.style.borderColor = '#57aa7f';
            }
            inputText.placeholder = isEncodeMode ? "è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬" : "è¯·è¾“å…¥è¦è§£ç çš„æ–‡æœ¬";
            
            // æ›´æ–°è¾“å‡ºæ¡†å ä½ç¬¦
            base16Output.placeholder = isEncodeMode ? "Base16ç¼–ç ç»“æœ" : "Base16è§£ç ç»“æœ";
            base32Output.placeholder = isEncodeMode ? "Base32ç¼–ç ç»“æœ" : "Base32è§£ç ç»“æœ";
            base58Output.placeholder = isEncodeMode ? "Base58ç¼–ç ç»“æœ" : "Base58è§£ç ç»“æœ";
            base64Output.placeholder = isEncodeMode ? "Base64ç¼–ç ç»“æœ" : "Base64è§£ç ç»“æœ";
            base64urlOutput.placeholder = isEncodeMode ? "Base64urlç¼–ç ç»“æœ" : "Base64urlè§£ç ç»“æœ";
            
            // é‡æ–°æ‰§è¡Œè½¬æ¢
            convertEncoding();
        }

        function copyText(outputElement, button) {
            const textToCopy = outputElement.value;
            if (textToCopy) {
                navigator.clipboard.writeText(textToCopy)
                    .then(() => {
                        button.textContent = "å·²å¤åˆ¶";
                // 1ç§’åæ¢å¤æ–‡æ¡ˆä¸º"å¤åˆ¶"
                setTimeout(() => {
                    button.textContent = "å¤åˆ¶";
                }, 1000);
                    })
                    .catch((error) => {
                        console.error('å¤åˆ¶å¤±è´¥:', error);
                    });
            }
        }

        // ä¸ºå¤åˆ¶æŒ‰é’®æ·»åŠ é¼ æ ‡æ‚¬åœæ•ˆæœå’Œç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
        const copyButtons = [copyBase16, copyBase32, copyBase58, copyBase64, copyBase64url];
        const originalColors = {};
        
        // ä¿å­˜åŸå§‹é¢œè‰²
        copyButtons.forEach(button => {
            originalColors[button.id] = {
                backgroundColor: button.style.backgroundColor,
                borderColor: button.style.borderColor
            };
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            button.addEventListener('click', () => {
                if (button.id === 'copyBase16') copyText(base16Output, copyBase16);
                else if (button.id === 'copyBase32') copyText(base32Output, copyBase32);
                else if (button.id === 'copyBase58') copyText(base58Output, copyBase58);
                else if (button.id === 'copyBase64') copyText(base64Output, copyBase64);
                else if (button.id === 'copyBase64url') copyText(base64urlOutput, copyBase64url);
            });
            
            // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶
            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = '#57aa7f';
                button.style.borderColor = '#57aa7f';
            });
            
            // æ·»åŠ é¼ æ ‡ç§»å‡ºäº‹ä»¶
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = originalColors[button.id].backgroundColor;
                button.style.borderColor = originalColors[button.id].borderColor;
            });
        });
        
        // æ·»åŠ æ¨¡å¼åˆ‡æ¢æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        modeToggle.addEventListener('click', toggleMode);

        inputText.addEventListener('input', convertEncoding);

        // åˆå§‹åŒ–è°ƒç”¨ä¸€æ¬¡
        convertEncoding();
    </script>
    <a href="../../../index.html" class="back-to-home">ğŸ </a>
</body>

</html>